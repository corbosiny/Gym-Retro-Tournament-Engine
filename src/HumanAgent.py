import argparse
import gym
import retro
import os
import numpy
import time
import random
import numbers
from keyboard import *
from collections import deque

import Agent
import Discretizer

class HumanAgent(Agent.Agent):
    """ 
    Human playable agent that can be thrown into tournaments to help train or for fun
    """

    Z_INDEX = 1
    X_INDEX = 0
    C_INDEX = 8
    A_INDEX  = 10
    S_INDEX = 9
    D_INDEX = 11
    UP_INDEX = 4
    DOWN_INDEX = 5
    LEFT_INDEX = 6
    RIGHT_INDEX = 7       
    keyToIndexDict = {'z' : Z_INDEX, 'x' : X_INDEX , 'c' : C_INDEX, 'a' : A_INDEX, 's' : S_INDEX, 'd' : D_INDEX, "left" : LEFT_INDEX, "right" : RIGHT_INDEX, "up" : UP_INDEX, "down" : DOWN_INDEX}
    keysToControllerInputDict = {'z' : 'A', 'x' : 'B' , 'c' : 'C', 'a' : 'X', 's' : 'Y', 'd' : 'Z', "left" : "LEFT", "right" : "RIGHT", "up" : "UP", "down" : "DOWN"}

    def __init__(self, load= False, name= None, character= "ryu", verbose= True):
        """
        Initializes the agent and the underlying neural network
        
        Parameters
        ----------
        load
            A boolean flag that specifies whether to initialize the model from scratch or load in a pretrained model
        name
            A string representing the name of the model that will be used when saving the model and the training logs
            Defaults to the class name if none are provided
        character
            String representing the name of the character this Agent plays as

        verbose
            A boolean variable representing whether or not the print statements in the class are turned on
            Error messages however are not turned off

        Returns
        -------
        None
        """
        self.userInput = [0] * 12
        super().__init__(load, name, character, verbose)
        self.bindKeyEvents()

        if self.__class__.__name__ != "Agent":
            if not load: self.model = self.initializeNetwork()    								# Only invoked in child subclasses, Agent has no network
            elif load: self.loadModel()


    def saveModel(self, lossUpdate= None):
        """
        Saves the currently trained model in the default naming convention ../local_models/{Class_Name}/{Class_Name}.model
        
        Parameters
        ----------
        lossUpdate
            An integer value representing the mean loss after one training epoch,
            will be logged in this model's training log if supplied

        Returns
        -------
        None
        """
        pass

    def loadModel(self):
        """
        Loads in pretrained model object ../local_models/{Class_Name}/{Class_Name}.model
        
        Parameters
        ----------
        None

        Returns
        -------
        None
        """
        pass

    ### End of object methods

    ### Abstract methods for the child Agent to implement

    def getMove(self, obs, info):
        """
        Returns a set of button inputs generated by the Agent's network after looking at the current observation
        
        Parameters
        ----------
        obs
            The observation of the current environment, 2D numpy array of pixel values
        info
            An array of information about the current environment, like player health, enemy health, matches won, and matches lost, etc.
            A full list of info can be found in data.json

        Returns
        -------
        move
            Integer representing the move that was selected from the move list
        """
        keysPressed = [key for key, value in HumanAgent.keyToIndexDict.items() if self.userInput[value] == 1]
        controllerInputs = [HumanAgent.keysToControllerInputDict[key] for key in keysPressed]
        for actionIndex, combo in enumerate(self.environment._combos):
            truthValues = [button in combo for button in controllerInputs]
            if all(truthValues): return actionIndex
        else:
            return 0


    def bindKeyEvents(self):
        hook(self.keyEvent)

    def keyEvent(self, event):
        if event.event_type == KEY_DOWN:
            self.keyPressed(event)
        elif event.event_type == KEY_UP:
            self.keyReleased(event)


    def keyPressed(self, event):
        try:
            index = HumanAgent.keyToIndexDict[event.name]
            self.setUserInputIndex(index)
        except:
            pass # Not a valid game input, just ignore

    def keyReleased(self, event):
        try:
            index = HumanAgent.keyToIndexDict[event.name]
            self.clearUserInputIndex(index)
        except:
            pass # Not a valid game input, just ignore

    def clearUserInputIndex(self, index):
        self.updateUserInputIndex(index, 0)

    def setUserInputIndex(self, index):
        self.updateUserInputIndex(index, 1)

    def updateUserInputIndex(self, index, value):
        if index < 0 or index >= len(self.userInput):
            return
        
        self.userInput[index] = value

    def initializeNetwork(self):
        """
        To be implemented in child class, should initialize or load in the Agent's neural network
        
        Parameters
        ----------
        None

        Returns
        -------
        model
            A newly initialized model that the Agent will use when generating moves
        """
        return -1
    
    def prepareMemoryForTraining(self, memory):
        """
        To be implemented in child class, should prepare the recorded fight sequences into training data
        
        Parameters
        ----------
        memory
            A 2D array where each index is a recording of a state, action, new state, and reward sequence
            See readme for more details

        Returns
        -------
        data
            The prepared training data
        """
        pass

    def trainNetwork(self, data, model):
        """
        To be implemented in child class, Runs through a training epoch reviewing the training data and returns the trained model
        
        Parameters
        ----------
        data
            The training data for the model
        model
            The model for the function to train

        Returns
        -------
        model
            The newly trained model
        """
        pass

    ### End of Abstract methods

"""
Make a test Agent and run it through one training run on single player mode of streetfighter
"""
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Processes agent parameters.')
    parser.add_argument('-r', '--render', action= 'store_true', help= 'Boolean flag for if the user wants the game environment to render during play')
    args = parser.parse_args()
    import Lobby
    testLobby = Lobby.Lobby(mode= Lobby.Lobby_Modes.SINGLE_PLAYER)
    agent = HumanAgent()
    testLobby.addPlayer(agent)
    testLobby.executeTrainingRun(render= True)